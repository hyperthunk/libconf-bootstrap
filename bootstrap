#!/usr/bin/env escript
%% This escript bootstraps libconf for your system.
%% Call it like so:
%%      ./bootstrap [command]
%% 
%% Where command is one of
%%  * install  - installs libconf and any dependent tools
%%  * generate - creates a configure.erl from a config file
%%  * build    - creates a binary escript (archive) from a configure.erl input
%%  * auto     - (the default) performs `install' followed by generate and/or
%%               build, depending on your config file
%% 

-include_lib("kernel/include/file.hrl").

-define(CONFIG(K, C, D), (case lists:keymember(K, 1, C) of false -> D;
                                _ -> element(2, lists:keyfind(K, 1, C)) end)).
-define(CONFIG(K1, K2, C, D), ?CONFIG(K2, ?CONFIG(K1, C, []), D)).
-define(PATH(Parts), filename:join(Parts)).
-define(CWD, element(2, file:get_cwd())).

-record(project, {
    build_dir,
    deps_dir,
    temp_dir,
    rebar_bin,
    config
}).

main(Args) ->
    case code:which(binary) of
        non_existing ->
            abort("libconf currently requires the use of the `binary' module!~n"
                  "you will need to run this escript with a release >= R14~n", []);
        _ ->
            execute(Args)
    end.

execute(["--help"]) ->
    {ok, Bin} = file:read_file(escript:script_name()),
    Lines = re:split(binary_to_list(Bin), "\n", [{return, list}]),
    Comments = string:join(lists:sublist(Lines, 2, 11), "~n"),
    io:format(re:replace(Comments, "%% ", "",
              [global, {return, list}]) ++ "~n"),
    halt(0);
execute(_) ->
    Proj = setup(load_config()),
    io:format("~p~n", [Proj]),
    ok.

setup(P=#project{
        build_dir=Base,
        deps_dir=Lib,
        temp_dir=Temp,
        config=Config }) ->
    [ mkdir(Path) || Path <- [Base, Lib, Temp] ],
    Rebar = verify_rebar_install(?PATH([Temp, "rebar.zip"]), Config),
    install_alt_deps(Base, Config),
    BuildConf = verify_build_config(P),
    P#project{ rebar_bin=Rebar }.

install_alt_deps(Base, Config) ->
    PluginDir = ?PATH([Base, "plugins"]),
    mkdir(PluginDir),
    case fetch("https://github.com/hyperthunk/rebar_alt_deps/zipball/master",
               ?PATH([PluginDir, "rebar_alt_deps.erl"]), Config) of
        {ok, _} ->
            ok;
        Err ->
            abort("Unable to fetch rebar_alt_deps: ~p~n", [Err])
    end.

verify_build_config(#project{ build_dir=Base, deps_dir=Lib, config=Config }) ->
    Cfg = generate_config(Base, Lib, Config),
    write_config(Cfg, Base).

generate_config(Base, Lib, Config) ->
    Overrides = ?CONFIG(rebar_config, Config, []),
    Opts = default_rebar_config(Base, Lib, Config),
    lists:map(apply_config_overrides(Overrides), Opts).

apply_config_overrides(Overrides) ->
    fun({K, V}=Pair) ->
        case lists:keyfind(K, 1, Overrides) of
            false ->
                Pair;
            NewValue ->
                NewValue
        end
    end.

default_rebar_config(Base, Lib, Config) ->
    DepsDir = ?CONFIG(rebar_config, deps_dir, Config, "lib"),
    [{deps_dir, DepsDir},
     {alt_deps, [{libconf, ".*"}]},
     {alt_repositories, [{libconf, {github, "hyperthunk"}}]},
     {plugin_dir, ?PATH([Base, "plugins"])},
     {plugins, [rebar_alt_deps]}].

rewrite_opts(BaseConfig) ->
    fun(Key, Opts) ->
        Replacement = proplists:get_value(Key, BaseConfig, undefined),
        overwrite({Key, Replacement}, Opts)
    end.

overwrite({Key, [_|_]=Value}, Opts) ->
    case lists:keyfind(Key, 1, Opts) of
        false ->
            [{Key, Value}|Opts];
        {Key, Config} when is_list(Config) ->
            lists:keyreplace(Key, 1, Opts, {Key, Value ++ Config});
        _ ->
            lists:keyreplace(Key, 1, Opts, {Key, Value})
    end;
overwrite({_Key, []}, Opts) ->
    Opts;
overwrite({_Key, undefined}, Opts) ->
    Opts;
overwrite({Key, Value}, Opts) ->
    case lists:keyfind(Key, 1, Opts) of
        false ->
            [{Key, Value}|Opts];
        _ ->
            lists:keyreplace(Key, 1, Opts, {Key, Value})
    end.

mkdir(Path) ->
    io:format("Ensure ~s~n", [Path]),
    case filelib:ensure_dir(Path) of
        ok ->
            file:make_dir(Path);
        {error, eexist} ->
            file:make_dir(Path);
        Err ->
            Err
    end.

verify_rebar_install(Target, Config) ->
    case os:find_executable("rebar") of
        false ->
            install_rebar(Target, Config);
        Path ->
            io:format("Using previously installed rebar: ~s~n", [Path]),
            Path
    end.

install_rebar(Target, Config) ->
    % we install the stock rebar for bootstrapping purposes
    Dest = ?PATH([filename:dirname(Target), "rebar"]),
    Exe = filename:join(Dest, "rebar"),
    case filelib:is_regular(Exe) of
        true ->
            io:format("Using previously installed rebar: ~s~n", [Exe]),
            Exe;
        false ->
            Url = "https://github.com/basho/rebar/zipball/master",
            case fetch(Url, Target, Config) of
                {error, Error} ->
                    abort("Unable to download rebar - ~p~n"
                          "please check your config/environment and try again~n",
                          [Error]);
                {ok, Target} ->
                    case zip:extract(Target, [memory]) of
                        {error, Reason} ->
                            abort("Unable to extract archive ~s: ~p~n",
                                  [Target, Reason]);
                        {ok, FileList} ->
                            [ file:write_file(rename(Path, Dest),
                                                Data, [write]) ||
                                                {Path, Data} <- FileList ],
                            Bootstrap = ?PATH([Dest, "bootstrap"]),
                            chmod_x(Bootstrap),
                            io:format("building rebar using ~s~n", [Bootstrap]),
                            case exec("./bootstrap", [{cd, Dest}]) of
                                {ok, _} ->
                                    chmod_x(Exe), Exe;
                                Err ->
                                abort("Unable to compile rebar: ~p~n", [Err])
                            end
                    end
            end
    end.

chmod_x(File) ->
    io:format("chmod +x ~s~n", [File]),
    {ok, FI} = file:read_file_info(File),
    ok = file:change_mode(File, FI#file_info.mode bor 8#00100).

exec(Command, Env) ->
    PortSettings = [exit_status, {line, 16384}, stderr_to_stdout, hide],
    sh_loop(open_port({spawn, Command}, PortSettings ++ Env), []).

sh_loop(Port, Acc) ->
    receive
        {Port, {data, {eol, Line}}} ->
            sh_loop(Port, [Line ++ "\n" | Acc]);
        {Port, {data, {noeol, Line}}} ->
            sh_loop(Port, [Line | Acc]);
        {Port, {exit_status, 0}} ->
            {ok, lists:flatten(lists:reverse(Acc))};
        {Port, {exit_status, Rc}} ->
            {error, {Rc, lists:flatten(lists:reverse(Acc))}}
    end.

rename(Path, Dest) ->
    [_|P] = filename:split(Path),
    Target = filename:join(Dest, filename:join(P)),
    filelib:ensure_dir(Target),
    Target.

abort(Msg, Args) ->
    io:format(Msg, Args), halt(1).

load_config() ->
    Bs = erl_eval:new_bindings(),
    case file:path_open([?CWD], "bootstrap.config", [read]) of
        {ok, Fd, _} ->
            try eval_stream(Fd, return, Bs) of
                {ok, C} ->
                    BuildDir = ?CONFIG(build_dir, C, ?CWD),
                    Default = ?PATH([BuildDir, "lib"]),
                    DepsDir = ?CONFIG(rebar_config, deps_dir, C, Default),
                    Temp = ?PATH([BuildDir, ".temp"]),
                    #project{ build_dir=BuildDir, deps_dir=DepsDir,
                              temp_dir=Temp, config=C };
                E1 ->
                    E1
            after
                file:close(Fd)
            end;
        {error, enoent} ->
            abort("bootstrap.config file not found!~n", []);
        E2 ->
            abort("Unable to load config: ~p~n", [E2])
    end.

eval_stream(Fd, Handling, Bs) ->
    eval_stream(Fd, Handling, 1, undefined, [], Bs).

eval_stream(Fd, H, Line, Last, E, Bs) ->
    eval_stream2(io:parse_erl_exprs(Fd, '', Line), Fd, H, Last, E, Bs).

eval_stream2({ok,Form,EndLine}, Fd, H, Last, E, Bs0) ->
    try erl_eval:exprs(Form, Bs0, none,
                        {value,
                        fun(Func, Args) when is_function(Func) ->
                            Func(Args);
                           ({Mod, Func}, Args) ->
                            erlang:apply(Mod, Func, Args)
                        end}) of
        {value, V, Bs} ->
            eval_stream(Fd, H, EndLine, {V}, E, Bs)
    catch Class:Reason ->
        Error = {EndLine, ?MODULE, {Class, Reason, erlang:get_stacktrace()}},
        eval_stream(Fd, H, EndLine, Last, [Error|E], Bs0)
    end;
eval_stream2({error,What,EndLine}, Fd, H, Last, E, Bs) ->
    eval_stream(Fd, H, EndLine, Last, [What | E], Bs);
eval_stream2({eof,EndLine}, _Fd, H, Last, E, _Bs) ->
    case {H, Last, E} of
        {return, {Val}, []} ->
            {ok, Val};
        {return, undefined, E} ->
            {error, hd(lists:reverse(E, [{EndLine,?MODULE,undefined_script}]))};
        {ignore, _, []} ->
            ok;
        {_, _, [_|_] = E} ->
            {error, hd(lists:reverse(E))}
    end.

fetch(Url, Target, C) ->
    case get({?MODULE, httpc}) of
        started ->
            ok;
        _ ->
            inets:start(),
            application:load(sasl),
            application:set_env(sasl, sasl_error_logger, false),
            lists:map(fun application:start/1, [sasl, crypto, public_key, ssl]),
            Timeout = ?CONFIG(remote_net_timeout, C, 6000),
            ProxyHost = ?CONFIG(remote_proxy_host, C, undefined),
            case ProxyHost of
                undefined ->
                    httpc:set_options([{timeout, Timeout},
                                       {connect_timeout, Timeout}]);
                Host ->
                    Port = ?CONFIG(remote_proxy_port, C, "8080"),
                    httpc:set_options([{proxy, {{Host, Port}, ["localhost"]}},
                                       {timeout, Timeout},
                                       {connect_timeout, Timeout}])
            end,
            put({?MODULE, httpc}, started)
    end,
    mkdir(filename:dirname(Target)),
    Request = {Url, [{"User-Agent", "Erlang-Rebar"}]},
    io:format("Attempting to fetch ~s into ~s~n", [Url, Target]),
    case httpc:request(get, Request, [{relaxed, true}],
                                     [{stream, Target}, {full_result, true}]) of
        {ok, saved_to_file} ->
            io:format("Successfully fetched remote archive...~n", []),
            {ok, Target};
        {ok, {{_, 404, _}, _, _}} ->
            io:format("~s not found!~n", [Url]),
            {error, missing};
        Error ->
            io:format("Error trying to load remote: ~p~n", [Error]),
            {error, Error}
    end.

